## 자바스크립트에서 `==`와 `===`가 어떻게 다른지 알려주세요.

자바스크립트는 **'약타입 언어'**입니다. 즉 변수나 상수의 타입을 인터프리터가 형변환하여 연산이나 처리를 할 수 있는 언어인데, 그렇기 때문에 이를 두가지 유형으로 비교하고자 나온 연산자가 바로 `==`와 `===`입니다. 

`==`는 두 가지의 다른 타입의 변수를 비교할 때 앞에 나온 타입으로 형변환하여 그 결과가 같은지를 비교하는 연산자입니다. 예를 들어,

```js
65535 == '65535' // true
true == 1 // true
```

와 같이 서로 다른 타입의 비교도 가능해집니다. Number인 65535는 String인 '65535'와 비교될 때, Number에서 String으로 형변환이 이루어지고 결국 '65535'와 '65535'로 비교가 되어 true를 반환하는 것입니다. 아래의 Boolean인 true도 Number인 1과 비교되면서 Number로 형변환이 이루어지며 그 값이 1로 변환돼 true를 반환하죠. 이렇듯 `==`는 비교하는 대상을 비교되는 대상의 타입으로 형변환하여 그 값을 비교하는 연산자입니다.

`===`는 `==`와 다르게 형변환없이 타입까지 따져 비교하는 연산자인데요, 예를 또 보자면,

```js
false === 0 // false
'255' === 255 // false
'true' === true // false
```

와 같이 `==`에서는 true를 반환할 연산들도 false를 반환하는데요, 이는 두 비교자의 타입 역시 비교하기 때문에 false를 반환하는 것입니다. `false`는 Number로 형변환했을 때 0이 나오지만 그 이전에 Boolean타입이죠. 그렇기 때문에 Number인 0과 비교했을 때 타입이 다르기 때문에 false를 반환한 것입니다. 그 아래의 `'255' === 255`나 `'true' === true`도 마찬가지로 타입이 같지 않기 때문에 false를 반환한 것입니다.

## 자바스크립트에서 **얕은 복사**와 **깊은 복사**에 대해 설명해 주세요.

먼저, JavaScript에는 **원시값**과 **참조값**이 존재합니다. 원시값은 변수의 메모리에 저장되는 가장 기본적인 데이터 형태인데요, JS의 5가지 원시타입이 여기 해당됩니다. 참조값은 여러 자료형으로 구성되는 메모리에 저장된 **객체**입니다. 변수에 객체를 저장하면 독립된 메모리 공간에 원시값을 저장하고, 변수에 원시값이 저장된 메모리 공간의 **참조**를 저장하게 됩니다. 그래서 할당된 변수를 조작하는 것은 사실 객체 자체를 조작하는 것이 아닌, 해당 객체의 참조를 조작하는 것입니다. 즉, 원시값 a를 얕은 복사한 b는 a를 참조하고 있으며, a가 수정되면 b도 수정이 됩니다. 거꾸로 b는 a를 참조하는 메모리 어드레스만을 기록하고 있기 때문에 b를 수정해도 a에게 영향을 끼치지는 않습니다. 하지만 a를 깊은 복사한다면 어떨까요?

깊은 복사는 새로운 메모리 공간에 복사되는 원시값을 그대로 복사해오며, 참조도 끊어지게 됩니다. 마치 체세포분열 같은데요, 한 몸에서 시작했지만 복사가 끝나면 서로는 완전히 독립된 개체가 됩니다. 원시값 a를 깊은 복사한 b는 수정해도 b가 바뀔 뿐, 서로에게 어떤 영향도 끼치지 않습니다. 깊은 복사가 우리가 원래 생각하던 복사의 의미와 가깝죠? 하지만 JS에서 얕은 복사가 기본이 된 이유가 있습니다. 바로 성능인데요, 깊은 복사는 이름대로 변수의 심층적인 요소까지 모조리 복사해서 새로운 객체를 만들어냅니다. 이러한 과정은 시스템 리소스를 유의미하게 많이 사용하며, 이것은 페이지의 렌더링 타임에 유의미한 영향을 끼칩니다. 
