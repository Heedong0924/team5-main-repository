# 2주차 Weekly Paper

## Git에서 `branch merge` 방법들과 각 방법의 특징을 설명해 주세요.
Git에서의 merge 방법은 크게 네 가지로 나눌 수 있습니다. Fast-Foward Merge와 Recursive Merge, Squash and Merge, 그리고 Rebase and Merge입니다. 지금부터 설명드릴 시츄에이션은 main 브랜치에서 develop 브랜치가 분기되어 나오고, develop 브랜치를 main 브랜치에 Merge 할 시츄에이션이라고 가정합니다.

### Fast-Forward Merge
main 브랜치에서 develop 브랜치가 분기되어 나뉘었고, main 브랜치에 아무런 작업이 되어있지 않을 때 쓰이는 merge 방법입니다. Fast-Forward 라는 이름처럼, merge 당하는 main 브랜치를 develop 브랜치의 커밋에 맞춰 '빨리감는' 방식으로 해쉬값까지 동일하게 복사합니다. 헤드는 가장 최근에 했던 커밋에 위치해 있습니다. 혼자 쓰는 레포에 브랜치를 나누어 작업할 때 가장 많이 쓰는 Merge 방법입니다.

### Recursive Merge
main 브랜치에서 develop 브랜치가 분기되어 나뉘었고, main 브랜치와 develop 브랜치에 각기 다른 커밋이 들어갔을 때 사용하는 Merge 방법입니다. main 브랜치에 develop 브랜치의 분기되고 나서의 커밋 내용들을 합친 merge 커밋을 main 브랜치에 만듭니다. 가장 자주 사용되는 Merge 방법입니다. 

> 위의 두 머지 방법은 브랜치를 보존한 채 머지 커밋을 만들어 머지하는 방식입니다. Github에는 `Create a merge commit`이라는 이름으로 상황에 따라 다르게 머지 커밋을 생성하고 있습니다.

### Squash and Merge
두 브랜치를 합쳐서 머지 커밋을 만들되, 하나의 머지 커밋 안에 모든 커밋의 변경사항을 전부 Squash해버리기 때문에, 내역은 깔끔하게 남지만 변경사항이 머지 되기 전 어떤 과정에서 변경되었는지 알기 힘들다는 것이 단점입니다.

### Rebase and Merge
분기된 브랜치의 커밋을 머지될 브랜치에 그대로 옮기는 Merge 방법으로, main 브랜치의 가장 최근 커밋 위에 시간순으로 develop 브랜치의 커밋이 쌓입니다. interactive rebase로 커밋을 합치거나, 버리거나, 내용을 수정할 수도 있습니다. 어떤 시점에서 머지가 되었는지 알기 힘들다는 단점 또한 존재합니다.

<hr>

## git flow 브랜치 전략에 대해 설명해주세요.

크게 5가지 브랜치로 형상을 관리합니다. `main`, `develop`, `feature`, `release`, `hotfix`로 나뉘는데, 각자의 역할이 다 다르고 머지 전략또한 다릅니다. 

- `main`: 배포 가능한 상태의 브랜치를 뜻합니다. 해당 버전의 기능개발이나 버그는 다 잡혀서 배포가 되어 있는 브랜치이며, CI/CD상에서 이 브랜치에 자동화가 물려있는 경우가 많기 때문에 이 브랜치에 머지하려고 하면 경고를 띄우게 만드는 세팅을 하기도 합니다. 

- `develop`: 현재 개발중인 브랜치를 뜻합니다. 주로 `main`의 다음 버전을 위해 브랜치를 따고, 이 브랜치에서 다시 `feature`단위로 브랜치를 다시 따는 경우가 흔합니다. 

- `feature`: 개발중인 기능 브랜치를 뜻합니다. 기능은 한 번에 하나만 개발하지 않기 때문에 여러개가 될 수도 있고, 머지 후 도입 시 기능이 좋지 못하면 브랜치가 버려지는 일도 존재합니다. 보통 개발자의 로컬 저장소에만 있는 브랜치이고, 리모트에는 push하지 않습니다.

- `release`: `main` 브랜치에 머지하기 전에 검토나 QA를 하기 위해 머지하는 브랜치입니다. 이 때 Github의 태그 기능이 쓰이며, 여기서 발견한 버그는 `develop` 브랜치에도 적용시켜줘야 합니다. 

- `hotfix`: 긴급하게 고쳐야 할 버그나 기능이 생겼을 때 만드는 브랜치로, `main`에서 주로 따와서 Squash and merge로 병합되어 사라지는 일회성 브랜치입니다.
