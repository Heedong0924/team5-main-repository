# Iterator에 대해

멘토 질문 시간에 질문했던 Iterator에 대해 자습하는 문서입니다.

## Iterator란 무엇인가요?

> JavaScript에서 반복자(Iterator)는 시퀀스를 정의하고 종료시의 반환값을 잠재적으로 정의하는 객체입니다. ... 반복자를 생성하면 next() 메소드를 반복적으로 호출하여 명시적으로 반복시킬 수 있습니다. 반복자를 반복시키는 것은 일반적으로 한 번씩만 할 수 있기 때문에, 반복자를 소모시키는 것이라고 할 수 있습니다. 마지막 값을 산출하고나서 next()를 추가적으로 호출하면 {done: true}. 가 반환됩니다. - _mdn web docs_

즉 지금까지 배워온 개념을 대입해보면 일반적인 for문에서의 i에 가깝다고 할 수 있겠습니다(for문에서 i라고 쓰는 것도 iterator의 약자라서 i라고 쓴다고 하네요). 정확한 동작 예시는 _mdn web docs_ 에서 같은 동작을 하는 함수의 코드를 보여주면서 원리를 설명하는데요, 같이 보시죠.

```js
function makeRangeIterator(start = 0, end = Infinity, step = 1) {
  var nextIndex = start;
  var n = 0;

  var rangeIterator = {
    next: function () {
      var result;
      if (nextIndex < end) {
        result = { value: nextIndex, done: false };
      } else if (nextIndex == end) {
        result = { value: n, done: true };
      } else {
        result = { done: true };
      }
      nextIndex += step;
      n++;
      return result;
    },
  };
  return rangeIterator;
}
```

이 함수는 3개의 인자를 가지고 모종의 **for없는 for문**을 돌게 됩니다. rangeIterator 안에 if문으로 분기된 result가 nextIndex의 끝을 맞이하기 전까지 next() 메서드를 반복적으로 호출하면서 `end = Infinity`만큼의 result와 rangeIterator를 return하는 것이지요. 여기서 알 수 있는 것은 iterator는 반복 가능하며 할당된 값을 다 뱉어내고 나면 끝났다고 알려주기까지 하는 녀석이라는 것입니다. 이 객체는 반복 가능한 자료형 중에 Symbol 타입으로써 Capsulated된 상태로 들어있습니다. 

## 그렇다면 배열이란 무엇인가요?

_mdn web docs_ 에서는 배열을 이렇게 정의합니다.

- JavaScript 배열은 크기를 조정이 가능하고, 다양한 데이터 형식을 혼합하여 저장할 수 있습니다.
- JavaScript 배열은 연관 배열이 아니므로 **임의의 문자열을 인덱스로 사용하여 배열 요소에 접근할 수 없습니다.**
- JavaScript 배열은 **0 인덱스**입니다.
- JavaScript 배열 복사 연산은 **얕은 복사본**을 생성합니다.

2번째 항목에서 <연관배열>이라는 말이 나오는데, 이는 Object나 Dictionary와 같은 키밸류쌍이 아니라 단순히 값만 가지고 있는 자료형이기 때문에 문자열을 인덱스로써 활용할 수 없다는 말입니다. 그리고 마지막 항목이 조금 어려운데요, 기술면접 시간에도 자주 등장하는 단어인 <얕은 복사(Shallow Copy)>입니다. 

### 얕은 복사와 깊은 복사

먼저, JavaScript에는 **원시값**과 **참조값**이 존재합니다. 원시값은 변수의 메모리에 저장되는 가장 기본적인 데이터 형태인데요, JS의 5가지 원시타입이 여기 해당됩니다. 참조값은 여러 자료형으로 구성되는 메모리에 저장된 **객체**입니다. 변수에 객체를 저장하면 독립된 메모리 공간에 원시값을 저장하고, 변수에 원시값이 저장된 메모리 공간의 **참조**를 저장하게 됩니다. 그래서 할당된 변수를 조작하는 것은 사실 객체 자체를 조작하는 것이 아닌, 해당 객체의 참조를 조작하는 것입니다. 즉, 원시값 a를 얕은 복사한 b는 a를 참조하고 있으며, a가 수정되면 b도 수정이 됩니다. 거꾸로 b는 a를 참조하는 메모리 어드레스만을 기록하고 있기 때문에 b를 수정해도 a에게 영향을 끼치지는 않습니다. 하지만 a를 깊은 복사한다면 어떨까요?

깊은 복사는 새로운 메모리 공간에 복사되는 원시값을 그대로 복사해오며, 참조도 끊어지게 됩니다. 마치 체세포분열 같은데요, 한 몸에서 시작했지만 복사가 끝나면 서로는 완전히 독립된 개체가 됩니다. 원시값 a를 깊은 복사한 b는 수정해도 b가 바뀔 뿐, 서로에게 어떤 영향도 끼치지 않습니다. 깊은 복사가 우리가 원래 생각하던 복사의 의미와 가깝죠? 하지만 JS에서 얕은 복사가 기본이 된 이유가 있습니다. 바로 성능인데요, 깊은 복사는 이름대로 변수의 심층적인 요소까지 모조리 복사해서 새로운 객체를 만들어냅니다. 이러한 과정은 시스템 리소스를 유의미하게 많이 사용하며, 이것은 페이지의 렌더링 타임에 유의미한 영향을 끼칩니다. 

## ES6에 변경된 자바스크립트

**ES6(ECMAScript 6)** 는 2015년에 도입된 자바스크립트의 6번째 표준안입니다. ES6를 살펴보면 우리가 강의시간에 배운 것도 있고 못 배운 것도 있지만, 여기서 눈여겨봐야 할 건 <전개 구문(Spread Operator)>입니다.

> 전개 구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 0개 이상의 인수 (함수로 호출할 경우) 또는 요소 (배열 리터럴의 경우)로 확장하여, 0개 이상의 키-값의 쌍으로 객체로 확장시킬 수 있습니다. - _mdn web docs_

원문에는 Object Literal의 경우도 설명했지만, 우리가 주목할 부분은 <반복 가능한 객체>라는 표현입니다. 객체가 iterable하여 반복 가능할 때, Spread Operator는 객체의 원소들을 다 펼쳐서 꺼내줍니다. 즉, iterator가 있으면 Spread Operator를 사용할 수 있다는 말이 되겠지요. 

### var, let, const의 차이점

ES6에서 가장 크게 달라진 점이 있다면 `let`과 `const`의 등장이겠죠. 
기존 JS에서 변수를 선언하는데 사용되던 `var`는 문제가 많았습니다. 우선 `var`는 **재선언되고, 업데이트될 수 있습니다.** 이것이 짧은 코드라면 별 문제가 되지 않겠지만, 재선언이 가능하다는 말은 곧 의도하지 않았더라도 겹치는 변수명을 사용하면 원래 의도와 다른 값이 재선언될 수 있다는 말인데요, 짧은 코드라면 버그를 찾아내기 쉽겠지만 변수의 개수가 많아지고 어떤 변수가 어디에 선언됐는지 찾기 힘들다면 이 버그가 어디에서 발생했는지 찾기 어려워지겠죠. 그리고 JS뿐만 아니라 다른 프로그래밍 언어에도 있는 <호이스팅>이라는 개념이 있는데요, 어떤 함수나 값의 선언이 사용보다 나중에 이루어진다면 그 선언문을 해당 범위의 맨 위로 끌어올리는 현상을 말합니다. 그렇기 때문에 다음과 같은 코드는

```js
console.log(greeter);
var greeter = '안녕하세요!';
```

다음과 같이 작동합니다.

```js
var greeter; // undefined로 초기화됨
console.log(greeter);
greeter = '안녕하세요!'
```

그렇기 때문에 다른 부분에서 이미 `greeter`를 사용했고, 위와 같은 호이스팅을 사용했다면, 의도와는 전혀 다른 동작을 할 수 있습니다. 호이스팅으로 끌어올려진 변수가 어떤 다른 부분에서 사용되었는지 찾기 힘들기 때문이죠. 그래서 `let`과 `const`가 등장했습니다.

- `let`: 변수가 선언된 {}으로 감싸진 블록스코프 내에서만 사용할 수 있습니다. `var`와는 다르게 업데이트는 가능하지만 재선언이 불가능합니다. 뭐가 다르냐면, 값을 `let`을 붙이지 않고 업데이트 할 수는 있지만 다시 `let`을 붙여 재선언은 할 수 없다는 말입니다.

```js
let greeting = '안녕하세요!';
let greeting = '반갑습니다.'; // error: Identifier 'greeting' has already been declared
```

하지만, 동일한 변수가 다른 블록스코프에서 선언된다면, 이 둘은 다른 변수 취급이 되어 에러가 발생하지 않습니다. 이것도 예상치 못한 동작을 할 수 있기 때문에 변수의 이름이 겹치는 것은 똑같이 조심해야겠죠.

```js
let greeting = '안녕하세요!';
if (true) {
  let greeting = '반갑습니다.';
  console.log(greeting); // '반갑습니다.'
}
console.log(greeting); // 안녕하세요!
```
```
```

그리고 호이스팅도 `var`와 똑같이 이루어지는데요, 차이점이라면 `let`으로 선언된 변수는 호이스팅될 때 `undefined`로 초기화되지 않고 곧장 에러를 뱉습니다. TDZ(Temporal Dead Zone)과 Lexical Binding이라는 개념도 있지만 조금 더 깊은 개념으로 이건 다른 문서에서 살펴보겠습니다.

- `const`: `let`과 비슷한 성질을 띄지만 **값을 업데이트할 수도 없고 재선언도 불가능합니다.** 그렇기 때문에 `const`는 선언할 때 반드시 값을 할당해주어야 합니다. 값이 변화해야 할 때를 제외하면 기본적으로 `const`를 사용한다고 하네요.
