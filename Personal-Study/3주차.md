# Iterator에 대해

멘토 질문 시간에 질문했던 Iterator에 대해 자습하는 문서입니다.

## Iterator란 무엇인가요?

> JavaScript에서 반복자(Iterator)는 시퀀스를 정의하고 종료시의 반환값을 잠재적으로 정의하는 객체입니다. ... 반복자를 생성하면 next() 메소드를 반복적으로 호출하여 명시적으로 반복시킬 수 있습니다. 반복자를 반복시키는 것은 일반적으로 한 번씩만 할 수 있기 때문에, 반복자를 소모시키는 것이라고 할 수 있습니다. 마지막 값을 산출하고나서 next()를 추가적으로 호출하면 {done: true}. 가 반환됩니다. - _mdn web docs_

즉 지금까지 배워온 개념을 대입해보면 일반적인 for문에서의 i에 가깝다고 할 수 있겠습니다(for문에서 i라고 쓰는 것도 iterator의 약자라서 i라고 쓴다고 하네요). 정확한 동작 예시는 _mdn web docs_ 에서 같은 동작을 하는 함수의 코드를 보여주면서 원리를 설명하는데요, 같이 보시죠.

```js
function makeRangeIterator(start = 0, end = Infinity, step = 1) {
  var nextIndex = start;
  var n = 0;

  var rangeIterator = {
    next: function () {
      var result;
      if (nextIndex < end) {
        result = { value: nextIndex, done: false };
      } else if (nextIndex == end) {
        result = { value: n, done: true };
      } else {
        result = { done: true };
      }
      nextIndex += step;
      n++;
      return result;
    },
  };
  return rangeIterator;
}
```

이 함수는 3개의 인자를 가지고 모종의 **for없는 for문**을 돌게 됩니다. rangeIterator 안에 if문으로 분기된 result가 nextIndex의 끝을 맞이하기 전까지 next() 메서드를 반복적으로 호출하면서 `end = Infinity`만큼의 result와 rangeIterator를 return하는 것이지요. 여기서 알 수 있는 것은 iterator는 반복 가능하며 할당된 값을 다 뱉어내고 나면 끝났다고 알려주기까지 하는 녀석이라는 것입니다. 이 객체는 반복 가능한 자료형 중에 Symbol 타입으로써 Capsulated된 상태로 들어있습니다. 

## 그렇다면 배열이란 무엇인가요?

_mdn web docs_ 에서는 배열을 이렇게 정의합니다.

- JavaScript 배열은 크기를 조정이 가능하고, 다양한 데이터 형식을 혼합하여 저장할 수 있습니다.
- JavaScript 배열은 연관 배열이 아니므로 **임의의 문자열을 인덱스로 사용하여 배열 요소에 접근할 수 없습니다.**
- JavaScript 배열은 **0 인덱스**입니다.
- JavaScript 배열 복사 연산은 **얕은 복사본**을 생성합니다.

2번째 항목에서 <연관배열>이라는 말이 나오는데, 이는 Object나 Dictionary와 같은 키밸류쌍이 아니라 단순히 값만 가지고 있는 자료형이기 때문에 문자열을 인덱스로써 활용할 수 없다는 말입니다. 그리고 마지막 항목이 조금 어려운데요, 기술면접 시간에도 자주 등장하는 단어인 <얕은 복사(Shallow Copy)>입니다. 

### 얕은 복사와 깊은 복사

먼저, JavaScript에는 **원시값**과 **참조값**이 존재합니다. 원시값은 변수의 메모리에 저장되는 가장 기본적인 데이터 형태인데요, JS의 5가지 원시타입이 여기 해당됩니다. 참조값은 여러 자료형으로 구성되는 메모리에 저장된 **객체**입니다. 변수에 객체를 저장하면 독립된 메모리 공간에 원시값을 저장하고, 변수에 원시값이 저장된 메모리 공간의 **참조**를 저장하게 됩니다. 그래서 할당된 변수를 조작하는 것은 사실 객체 자체를 조작하는 것이 아닌, 해당 객체의 참조를 조작하는 것입니다. 즉, 원시값 a를 얕은 복사한 b는 a를 참조하고 있으며, a가 수정되면 b도 수정이 됩니다. 거꾸로 b는 a를 참조하는 메모리 어드레스만을 기록하고 있기 때문에 b를 수정해도 a에게 영향을 끼치지는 않습니다. 하지만 a를 깊은 복사한다면 어떨까요?

깊은 복사는 새로운 메모리 공간에 복사되는 원시값을 그대로 복사해오며, 참조도 끊어지게 됩니다. 마치 체세포분열 같은데요, 한 몸에서 시작했지만 복사가 끝나면 서로는 완전히 독립된 개체가 됩니다. 원시값 a를 깊은 복사한 b는 수정해도 b가 바뀔 뿐, 서로에게 어떤 영향도 끼치지 않습니다. 깊은 복사가 우리가 원래 생각하던 복사의 의미와 가깝죠? 하지만 JS에서 얕은 복사가 기본이 된 이유가 있습니다. 바로 성능인데요, 깊은 복사는 이름대로 변수의 심층적인 요소까지 모조리 복사해서 새로운 객체를 만들어냅니다. 이러한 과정은 시스템 리소스를 유의미하게 많이 사용하며, 이것은 페이지의 렌더링 타임에 유의미한 영향을 끼칩니다. 

## ES6에 변경된 자바스크립트

**ES6(ECMAScript 6)** 는 2015년에 도입된 자바스크립트의 6번째 표준안입니다. ES6를 살펴보면 우리가 강의시간에 배운 것도 있고 못 배운 것도 있지만, 여기서 눈여겨봐야 할 건 <전개 구문(Spread Operator)>입니다.

> 전개 구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 0개 이상의 인수 (함수로 호출할 경우) 또는 요소 (배열 리터럴의 경우)로 확장하여, 0개 이상의 키-값의 쌍으로 객체로 확장시킬 수 있습니다. - _mdn web docs_

원문에는 Object Literal의 경우도 설명했지만, 우리가 주목할 부분은 <반복 가능한 객체>라는 표현입니다. 객체가 iterable하여 반복 가능할 때, Spread Operator는 객체의 원소들을 다 펼쳐서 꺼내줍니다. 즉, iterator가 있으면 Spread Operator를 사용할 수 있다는 말이 되겠지요. 
